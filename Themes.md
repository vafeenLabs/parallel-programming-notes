Темы к рассмотрению на лекциях
1 Параллелизм в вычислительных системах.
2 Асинхронные задачи.
3 Управление потоками средствами языка с++(запуск, передача
аргументов,
владение, инентификация, фоновый
режим).
4 Разделение данных между потоками.
5 Синхронизация параллельных
операций.
6 Управление потоками средствами OC Windows и Linux (WinAPI, POSIX).
7 Модель памяти и атомарные операции.
8 Проектирование структур данных для многопоточных приложений.
9 * Допольнительные
библиотеки для многопоточных приложений (OpenMP,
OpenMPI,…). Если останется время.
10 * Повторить по необходимости базовые понятия C++

План лекций

# Лекция 1 (ознакомительная)

Параллелизм в жизни, опрос/статистика по девайсам/ядрам у студентов.
ГЛАВА 1. Здравствуй, параллельный мир!
1.1. Что такое параллелизм?
1.1.1. Параллелизм в вычислительных системах
1.1.2. Подходы к организации параллелизма
1.2. Зачем нужен параллелизм?
1.2.1. Применение параллелизма для разделения обязанностей
1.2.2. Применение параллелизма для повышения производительности
1.2.3. Когда параллелизм вреден?
Определения поток/процесс из методички.
Запуск асинхронные задачи. Пример 01 Асинхронный запуск задач.docx.
Пример 01 Асинхронный вывод.docx (объяснить фичу с присваиванием таски и wait() в деструкторе).

# Лекция 2: Параллелизм в вычислительных системах

1.3. Параллелизм и многопоточность в С++
1.3.1. История многопоточности в С++
1.3.2. Поддержка параллелизма в новом стандарте
1.3.3. Эффективность библиотеки многопоточности
для C++
1.3.4. Платформенно-зависимые средства
1.4. В начале пути
1.4.1. Здравствуй, параллельный мир

ГЛАВА 2. Управление потоками
2.1. Базовые операции управления потоками
2.1.1. Запуск потока
2.1.2. Ожидание завершения потока
2.1.4. Запуск потоков в фоновом режиме
2.3. Передача владения потоком
2.5. Идентификация потоков

# Лекция 3: Разделение данных между потоками

2.2. Передача аргументов функции потока
2.4. Задание количества потоков во время выполнения
ГЛАВА 3. Разделение данных между потоками
3.1. Проблемы разделения данных между потоками
3.1.1. Гонки
3.1.2. Устранение проблематичных состояний гонки
3.2. Защита разделяемых данных с помощью мьютексов
3.2.1. Использование мьютексов в С++
3.2.2. Структурирование кода для защиты разделяемых
Данных
3.2.3. Выявление состояний гонки, внутренне присущих
интерфейсам

# Лекция 4: Разделение данных между потоками

Повторить:

- указатели на функции
- указатель на функцию с параметрами
- шаблон std::function 
- std::bind для передачи заказчику с параметрами
- std::bind для перевода указателя на std::placeholder::_x
- правило ноля правило пяти

3.2.4. Взаимоблокировка: проблема и решение
3.2.5. Дополнительные рекомендации, как избежать взаимоблокировок
3.2.6. Ошибка блокировки с помощью std::unique_lock
3.2.7. Передача владения мьютексом между контекстами
3.2.8. Выбор правильной гранулярности блокировки

# Лекция 5: Разделение данных между потоками

Повторить пройденный материал (основные моменты), чтобы студенты могли
приступить к выполнению Лабораторной работы
3.3. Другие средства защиты разделяемых данных
3.3.1. Защита разделяемых данных во время инициализации
3.3.2. Защита редко обновляемых структур данных
3.3.3. Рекурсивная блокировка

# Лекция 6: Синхронизация потоков

ГЛАВА 4. Синхронизация параллельных операций
4.1. Ожидание события или иного условия
4.1.1. Ожидание условия с помощью условных
переменных
4.1.2. Потокобезопасная очередь на базе условных переменных

# Лекция 7: Управление потоками в WinAPI

1. Дескрипторы (ручки), LPCVOID, LPVOID и другие типы данных WinAPI
1. Управление потоками в WinAPI
2.1. Создание потока
2.2. Приостановка потока
2.3. Завершение потока.

# Лекция 8: Управление потоками в WinAPI

Повторить (рассказать) про размеры базовых типов данных и выравнивание структур
Ответить (рассказать) на GetLastError() и выполнить поиск ошибок
3. Синхронизация потоков
3.1. Ожидание завершения потока
3.2. Объект ядра Событие
3.3. Объект ядра Мьютекс

# Лекция 9: Управление потоками в WinAPI

3.4. Объект ядра Семафор
3.5. Критические секции
Добавление CreateThread на практике
Утверждать (рассказывать) через ASSERT, STATIC_ASSERT

# Лекция 10: Управление потоками в Linux

Повторить:

- Директивы препроцессора сообщения #pragma-message, #error, #warning
- ошибка во многопоточных приложениях

1. Создание потока
2. Завершение потока
3. Ожидание потока 6
4. Досрочное завершение потока 6
5. Отсоединение потока 8
6. Синхронизация потоков 8
6.1. Мьютекс pthread_mutex_t 8

# Лекция 11: Управление приложениями в Linux

6.2. Семафоры sem_init 14
6.3. Условная переменная pthread_cond_timedwait
6.4. Ожидание потока pthread_join 18
6.5. Барьеры pthread_barrier_init 19
6.6. Spin-блокировки pthread_spin_init 21
7. Потоки versus проессы
